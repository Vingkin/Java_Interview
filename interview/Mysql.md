## 0x01. 为了减少IO，索引树会一次性加载吗

1. 数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G
2. 当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的就是逐一加载每个磁盘页（数据页），因为数据页对应着索引树的节点

## 0x02. B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO

InnoDB存储引擎中页的大小为16 KB，一般表的逐渐类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4-8个字节，也就是说一个页（B+tree中的一个节点）中大概存储`16KB/(8B+8B)=1K`个键值，换算出一页大概能存储1000条数据，深度为3可以存储`1000*1000*1000=10亿`条数据。。。

## 0x03. 为什么B+树比B树更适合做索引

1. **B+树的磁盘读写代价更低**
   * B+树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
2. **B+树的查询效率更加稳定**
   * 由于非叶节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一数据的查询效率相当。而B-树非叶子节点也存储数据，可能需要中序遍历。
3. **在范围查询上，B+树的效率也比B树高**
   * B+树的关键字都出现在叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成范围查询。

## 0x04. InnoDB为什么不建议用过长的字段作为主键

所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大

## 0x05. InnoDB为什么使用自增主键是一个很好的选择

InnoDB数据文件本身是一颗B+树，非单调的主键会造成在插入新纪录时，数据文件为了维持B+树的特性而频繁的分裂调整（页分裂）

## 0x06. Hash结构效率高，那为什么还要使用B+树索引呢

1. Hash索引仅能满足 `= , <> , IN` 查询。如果进行范围查询，哈希索引的时间复杂度会退化为O(n)。而树型的依然能够保持O(log2N)
2. Hash索引数据存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。
3. 对于联合索引的情况，Hash值是将联合索引键合并起来一起计算的，无法对单独的一个键或者几个索引键进行判断。
4. 对于等值查询来说，通常Hash索引的效率更高，不过当索引列的重复值过多，由于Hash冲突效率就会降低。

## 0x07. 索引的分类

1. 从**功能逻辑**上说，索引主要有4种，分别是普通索引、唯一索引、主键索引和全文索引
2. 从**物理实现方式**：聚簇索引和非聚簇索引
3. **作用字段个数**：单列索引和联合索引

## 0x08. 哪些情况适合创建索引

1. 字段的数值有唯一性的限制

   `业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引`。（来源：Alibaba）
   说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。

2. 频繁作为 WHERE 查询条件的字段

   某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。
   尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

3. 经常 GROUP BY 和 ORDER BY 的列

   索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 `对分组或者排序的字段进行索引` 。
   如果待排序的列有多个，那么可以在这些列上建立 `组合索引` 。

4. UPDATE、DELETE 的 WHERE 条件列

   对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。
   如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。

5. DISTINCT 字段需要创建索引

   有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

   索引列按`递增的顺序` 进行排序。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。

6. 多表 JOIN 连接操作时，创建索引注意事项

   * 首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
   * 其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
   * 最后， 对用于连接的字段创建索引，并且该字段在多张表中的 类型必须一致 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

7. 使用列数据类型小的创建索引

8. 使用字符串前缀创建索引

   * 【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。
   * 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

9. 区分度（散列性）高的适合作为索引

   数据相似性大的就不适合建立索引，如：`男女性别`

10. 使用最频繁的列放到联合索引左侧

    这样也可以较少的建立一些索引。同时，由于"`最左前缀原则`"，可以增加联合索引的使用率。

11. 在多个字段需要创建索引的情况下，联合索引优于单值

## 0x09. 哪些情况不适合创建索引

1. 在where种使用不到的字段

2. 数据量小的表

3. 有大量重复数据的列

4. 避免经常更新的表创建过多的索引

5. 不建议使用无序的值作为索引

   例如`身份证`、`UUID`(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、`MD5`、`HASH`、`无序长字符`串等。

6. 删除不再使用或很少使用的索引

7. 不要定义冗余或重复的索引。

## 0x0A. 索引下推

> Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。

示例：

```sql
alert table tb_people add index `zip_last_first` (`zipcode`, `lastname`, `firstname`)

select * from people
where zipcode = '000001'
and lastname like '%张%'
and address like '%北京市%'
```

上述添加了一个联合索引。select语句只有zipcode命中了联合索引，lastname因为%开头并不能命中，但是因为联合索引中有lastname，所以会先在联合索引中通过lastname进行过滤，然后再进行回表操作。这就是索引下推。

## 0x0B. EXISTS和IN的区分

如何选择需要看表的大小。`小表驱动大表`。

比如

```sql
select * from A where cc in (select cc from B)
select * from A where exists (select cc from B where B.cc = A.cc)
```

当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，

```java
for i in A
    for j in B
        if j.cc == i.cc then...
```

IN的逻辑

```java
for i in B
    for j in A
        if j.cc == i.cc then...
```

## 0x0C. COUNT(\*), COUNT(1)和COUNT(具体字段)

1. `COUNT(*)`和`COUNT(1)`都是对结果进行COUNT，`COUNT(*)`和`COUNT(1)`本质上并没有区别。
2. 如果采用的是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了`row_count`的值，而一致性则由表级锁来保证。如果是InnoDB，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个`row_count`变量，因此需要采用扫描全表，O(n)的复杂度。
3. 再InnoDB种如果采用`COUNT(具体字段)`来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引。对于`COUNT(*)`和`COUNT(1)`来说，他们不需要查找具体的行，只是统计行数，系统会`自动`采用占用空间小的二级索引来进行统计。如果有多个二级索引，会使用`key_len`小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。

## 0x0D. 关于SELECT(\*)

在表查询中，建议明确字段，不要使用\*作为查询的字段列表，推荐受用具体字段查询。

原因：

1. mysql在解析的过程中，会通过查询`数据字典`将\*按序转换成所有列名，这会大大消耗资源和时间。
2. 无法使用`覆盖索引`

## 0x0E. 多使用COMMIT

只要有可能，在程序中尽量多使用COMMIT，这样程序的性能能够得到提高，需求也会因为COMMIT所释放的资源而减少。

COMMIT所释放的资源：

1. 回滚段上用于恢复数据的信息
2. 被程序语句获得的锁
3. redo / undo log buffer中的空间
4. 管理上述3种资源种的内部花费

## 0x0F. 主键如何设计

### 自增ID的问题

1. 可靠性不高：存在自增ID回溯的问题，这个问题直到8.0才解决
2. 安全性不高：对外暴露的接口容易暴露信息。比如`/User/1`
3. 性能差：自增ID的性能较差，需要在数据库服务器端生成
4. 交互多：业务需要二外执行一次类似last_insert_id()的函数才能知道插入的子增值。
5. 局部唯一性：分布式问题

### 推荐的主键设计

对于核心业务，主键的设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。推荐使用UUID。

**UUID的特点：**

全局唯一，占用36字节，数据无序，插入性能差。

UUID如下图所示：

![](https://vingkin-1304361015.cos.ap-shanghai.myqcloud.com/interview/UUID.png)

**改造UUID**

若将时间高低位互换，则时间就是单调递增的了。MySQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。



## 0x04 数据库的悲观锁和乐观锁

