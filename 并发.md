## 0x00. sleep与yield

**sleep**

* 调用sleep会让当前线程从Running进入Timed Waiting（阻塞状态）状态
* 其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException
* 睡眠结束后的线程未必会立刻得到执行
* 建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性

**yield**

* 调用yield会让当前线程从Running进入Runnalbe（就绪状态）状态，然后调度执行其他同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果
* 具体的实现依赖于操作系统的任务调度器

**区别**

就绪状态有机会被任务调度器调用，阻塞状态不会。

sleep有休眠时间，yield没有时间参数

## 0x01. 线程优先级

Java中优先级最大10，最小1，默认为5，仅仅是一个提示，调度器可以忽略。

只有在cpu比较忙的时候，优先级较高的线程会获得更多的时间片，cpu空闲时，优先级几乎没什么用。

## 0x02. 线程状态

**五种状态**

> 操作系统层面

![](C:\Users\18300\Desktop\interview\imgs\image-20220225202048787.png)

* 初始状态：仅在语言层面创建了线程对象，还未与操作系统线程关联
* 可运行状态（就绪状态）：指该线程已经被创建（与操作系统线程相关），可以由CPU调度使用
* 运行状态：指获取了CPU时间片运行中的状态
* 阻塞状态：
  * 如果调用了阻塞API，如读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态
  * 等读写完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态
  * 与**可运行状态**的区别是，对阻塞状态的线程来说只要他们一直不唤醒，调度器就一直不会考虑调度他们。
* 终止状态：表示线程执行已经完毕，生命周期已经结束，不会再转换为其他状态

**六种状态**

> Java中Thread.State枚举描述的

![](C:\Users\18300\Desktop\interview\imgs\image-20220225202815248.png)

![](C:\Users\18300\Desktop\interview\imgs\image-20220303171324316.png)

* NEW：线程刚被创建，但是还没有调用start()方法
* RUNNABLE：当调用了start()方法之后的状态。涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（在Java中无法区分运行状态和可运行状态）
* BLOCKED、WAITING、TIMED_WAITING：都是Java API层面对【阻塞状态】的细分
* TERMINATED：当前线程运行结束

![Java 线程的状态 ](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png)

## 0x03. Monitor原理

Monitor被翻译成**监视器**或**管程**

每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁之后，该对象头的Mark Word中就被设置成指向Monitor对象的指针

Monitor的结构如下：

![](C:\Users\18300\Desktop\interview\imgs\image-20220227152703623.png)

* 刚开始Monitor中的Owner为null
* 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner
* 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED
* Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的
* 途中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程

注意：

* synchronized必须是进入同一个锁对象的monitor才有上述的效果（一个锁对象对应着一个monitor）
* 不加synchronized的对象不会关联监视器，不遵从上述规则

## 0x04. sleep()和wait()的区别

1. sleep是Thread方法，wait是Object方法
2. sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起使用
3. **sleep不会释放锁对象，wait会释放锁对象**

他们的线程状态都是TIMED_WAITING

## 0x05. 保护性暂停模式

> 用于一个线程等待另一个线程的执行结果

* 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject
* 如果有结果不断从一个线程到另一个线程，那么可以使用消息队列（生产者消费者模式）
* JDK中，join和future采用的就是该模式
* 因为一个线程需要等待另一个线程的执行结果，所以归结于同步模式

![](C:\Users\18300\Desktop\interview\imgs\image-20220303155836268.png)

## 0x06. 生产者消费者模式

* 与前面的保护性暂停中的GuardObjct不同，不需要产生结果和消费结果的线程一一对应
* 消费队列可以用来平衡生产和消费的线程资源
* 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据
* 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据
* JDK中各种阻塞队列，采用的就是这种模式

![](C:\Users\18300\Desktop\interview\imgs\image-20220303162257793.png)

## 0x07. 变量的线程安全分析

**成员变量和静态变量的线程安全分析**

* 如果变量没有在线程间共享，那么变量是安全的
* 如果变量在线程中共享
  * 如果只有读操作，则线程安全
  * 如果有写操作，则该变量属于临界资源，需要考虑线程安全问题

**局部变量线程安全分析** 

* 局部变量被初始化为基本数据类型则是安全的
* 当局部变量是引用变量时则需要进行逃逸分析判断
  * 如果该对象没有逃离方法的作用范围，则线程安全
  * 如果该对象逃离了方法的作用范围，则线程不安全

## 0x08. 轻量级锁

> 用于优化重量级锁，其中还涉及到锁膨胀和自旋锁优化
>
> https://blog.csdn.net/m0_37989980/article/details/111408759#t5

![](C:\Users\18300\Desktop\interview\imgs\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70.png)

## 0x09. 偏向锁

> 用于优化轻量级锁重入
>
> https://blog.csdn.net/m0_37989980/article/details/111408759#t8

![](C:\Users\18300\Desktop\interview\imgs\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70.png)

![](C:\Users\18300\Desktop\interview\imgs\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70.png)

## 0x0A. wait和notify

> https://blog.csdn.net/m0_37989980/article/details/111412907#t0

## 0x0B. park和unpark

> https://blog.csdn.net/m0_37989980/article/details/111412907#t8

## 0x0C. CAS的特点

结合CAS和volatile可以实现无锁并发，适用于线程数少、多核CPU的场景下。

* CAS是基于乐观锁的思想（实际上并不是锁）：最乐观的估计，不怕别的线程来修复共享变量，就算改了也没关系，重试即可

* synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会

* CAS体现的是无锁并发，无阻塞并发

  * 因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
  * 但是如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响

## 0x0D. 原子引用ABA问题

> 主线程仅能判断出共享变量的值与初值A是否相同，不能感知到这种从A改为B又改回A的情况，如果主线程希望：
>
> 只要有其他线程【动过了】共享变量，那么自己的cas就算失败，这时仅比较值是不够的，还需要再加一个版本号

1. 通过AtomicStampedReference判断是否更改了版本号，传入的是整型变量
2. 通过AtomicMarkableReference判断是否被修改，传入的是布尔变量

## 0x0E. i++是否线程安全

> 不是
>
> 假设有1000个线程对i执行++操作，理论上ide结果应该是1000，实际并不是

每个线程都有自己的工作内存，每个线程需要用共享变量时必须先把共享变量从主存load到自己的工作内存，等完成对共享变量的操作时再save到主内存。

问题就出在一个线程读取主存的值后运算完还未刷回主存就被其他线程从主存中读取到了，这时候其他线程读取的数据就是脏数据了。

这也是经典的内存不可见问题，把count加上volatile也不能解决这个问题。因为volatile只能保证可见性并不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程的可见性，也不能保证线程之间读取到同样的值然后互相覆盖对方值的情况。

**解决方案**

1. 对i++操作的方法加同步锁，同时只能由一个线程执行i++
2. 使用支持原子类型操作的类，比如AtomicInteger，内部使用的是CAS



